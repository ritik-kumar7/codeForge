[
  {
    "id": 1,
    "title": "Two Sum",
    "difficulty": "Easy",
    "type": "Array / Hash Table",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "examples": [
      { "input": "nums = [2,7,11,15], target = 9", "output": "[0,1]" },
         { "input": "nums=[3,2,4], target=5", "output": "[0,1]" },
      { "input": "nums=[3,3], target=6", "output": "[0,1]" }
   
    ],
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists."
    ],
    "testCases": [
      { "input": "nums=[2,7,11,15], target=9", "output": "[0,1]" },
      { "input": "nums=[3,2,4], target=5", "output": "[0,1]" },
      { "input": "nums=[3,3], target=6", "output": "[0,1]" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/VBL_tlTnT6Q?si=7mVCiNJLfWT38TYd",
      "approach": "[Naive Approach] Generating all Possible Pairs - O(nÂ²) time and O(1) space. The basic approach is to generate all the possible pairs and check if any of them add up to the target value. [Optimized Approach] Using Hash Map - O(n) time and O(n) space. Store elements in hash map and check if complement exists."
    }
  },
  {
    "id": 2,
    "title": "Reverse Integer",
    "difficulty": "Medium",
    "type": "Math",
    "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside signed 32-bit range, return 0.",
    "examples": [
      { "input": "x = 123", "output": "321" },
      { "input": "x = -123", "output": "-321" }
    ],
    "constraints": ["-2^31 <= x <= 2^31 - 1"],
    "testCases": [
      { "input": "x=123", "output": "321" },
      { "input": "x=-120", "output": "321" },
      { "input": "x=1534236469", "output": "321" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/QBNm9Ow-Pko?si=BZkqMJKtPbnJv_DJ",
      "approach": "[Mathematical Approach] Extract digits using modulo and division - O(log n) time and O(1) space. Extract last digit using x % 10, add to result, and divide x by 10. Handle overflow by checking if result exceeds 32-bit integer range."
    }
  },
  {
    "id": 3,
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "type": "Math",
    "description": "Given an integer x, return true if x is palindrome integer.",
    "examples": [
      { "input": "x=121", "output": "true" },
      { "input": "x=-121", "output": "false" }
    ],
    "constraints": ["-2^31 <= x <= 2^31 - 1"],
    "testCases": [
      { "input": "x=121", "output": "true" },
      { "input": "x=-121", "output": "true" },
      { "input": "x=10", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/yubRKwixN-U?si=msH7K2e4pNa106A3",
      "approach": "[Reverse Half Approach] Reverse only half the number - O(log n) time and O(1) space. Reverse half digits and compare with remaining half. Handle even/odd digit cases separately."
    }
  },
  {
    "id": 4,
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "type": "Stack / String",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    "examples": [
      { "input": "s = '()'", "output": "true" },
      { "input": "s = '()[]{}'", "output": "true" }
    ],
    "constraints": ["1 <= s.length <= 10^4", "s consists of parentheses only"],
    "testCases": [
      { "input": "s='()'", "output": "true" },
      { "input": "s='(]'", "output": "true" },
      { "input": "s='([)]'", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/WTzjTskDFMg",
      "approach": "[Stack Approach] Use stack to track opening brackets - O(n) time and O(n) space. Push opening brackets to stack, pop when closing bracket matches. String is valid if stack is empty at end."
    }
  },
  {
    "id": 5,
    "title": "Merge Two Sorted Lists",
    "difficulty": "Medium",
    "type": "Linked List",
    "description": "Merge two sorted linked lists and return it as a new sorted list.",
    "examples": [
      { "input": "l1 = [1,2,4], l2 = [1,3,4]", "output": "[1,1,2,3,4,4]" }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50]",
      "-100 <= Node.val <= 100",
      "Both l1 and l2 are sorted in non-decreasing order."
    ],
    "testCases": [
      { "input": "l1=[1,2,4], l2=[1,3,4]", "output": "[1,1,2,3,4,4]" },
      { "input": "l1=[], l2=[]", "output": "[1,1,2,3,4,4]" },
      { "input": "l1=[], l2=[0]", "output": "[1,1,2,3,4,4]" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/XIdigk956u0",
      "approach": "[Two Pointer Approach] Compare nodes and merge - O(m+n) time and O(1) space. Use dummy node, compare current nodes of both lists, attach smaller node to result, advance pointer."
    }
  },
  {
    "id": 6,
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Easy",
    "type": "Array / Two Pointers",
    "description": "Given a sorted array nums, remove duplicates in-place such that each element appears only once.",
    "examples": [
      { "input": "nums = [1,1,2]", "output": "2, nums = [1,2,_]" }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-100 <= nums[i] <= 100",
      "nums is sorted in non-decreasing order."
    ],
    "testCases": [
      { "input": "nums=[1,1,2]", "output": "2" },
      { "input": "nums=[0,0,1,1,1,2,2,3,3,4]", "output": "2" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/DEJAZBq0FDA",
      "approach": "[Two Pointer Approach] In-place removal using slow-fast pointers - O(n) time and O(1) space. Keep slow pointer for unique elements, fast pointer to traverse array. Copy unique elements to slow pointer position."
    }
  },
  {
    "id": 7,
    "title": "Search Insert Position",
    "difficulty": "Easy",
    "type": "Binary Search / Array",
    "description": "Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be inserted.",
    "examples": [
      { "input": "nums = [1,3,5,6], target = 5", "output": "2" }
    ],
    "constraints": [
      "1 <= nums.length <= 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums contains distinct values sorted in ascending order."
    ],
    "testCases": [
      { "input": "nums=[1,3,5,6], target=5", "output": "2" },
      { "input": "nums=[1,3,5,6], target=2", "output": "2" },
      { "input": "nums=[1,3,5,6], target=7", "output": "2" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/K-RYzDZkzCI",
      "approach": "[Binary Search Approach] Find target or insertion position - O(log n) time and O(1) space. Use binary search to find target. If not found, left pointer gives insertion position."
    }
  },
  {
    "id": 8,
    "title": "Maximum Subarray",
    "difficulty": "Hard",
    "type": "Dynamic Programming / Array",
    "description": "Find the contiguous subarray which has the largest sum and return its sum.",
    "examples": [
      { "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]", "output": "6" }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "testCases": [
      { "input": "nums=[-2,1,-3,4,-1,2,1,-5,4]", "output": "6" },
      { "input": "nums=[1]", "output": "6" },
      { "input": "nums=[5,4,-1,7,8]", "output": "6" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/5WZl3MMT0Eg",
      "approach": "[Kadane's Algorithm] Dynamic programming approach - O(n) time and O(1) space. Keep track of maximum sum ending at current position. Update global maximum at each step."
    }
  },
  {
    "id": 9,
    "title": "Climbing Stairs",
    "difficulty": "Medium",
    "type": "Dynamic Programming",
    "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. Find how many distinct ways you can climb.",
    "examples": [
      { "input": "n=2", "output": "2" },
      { "input": "n=3", "output": "3" }
    ],
    "constraints": ["1 <= n <= 45"],
    "testCases": [
      { "input": "n=2", "output": "2" },
      { "input": "n=3", "output": "2" },
      { "input": "n=5", "output": "2" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/Y0lT9Fck7qI",
      "approach": "[Dynamic Programming] Fibonacci pattern - O(n) time and O(1) space. Ways to reach step n = ways to reach (n-1) + ways to reach (n-2). Use two variables to store previous results."
    }
  },
  {
    "id": 10,
    "title": "Symmetric Tree",
    "difficulty": "Easy",
    "type": "Binary Tree",
    "description": "Given the root of a binary tree, check whether it is symmetric around its center.",
    "examples": [
      { "input": "root = [1,2,2,3,4,4,3]", "output": "true" }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [1, 1000]",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      { "input": "root=[1,2,2,3,4,4,3]", "output": "true" },
      { "input": "root=[1,2,2,null,3,null,3]", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/nKggNAiEpBE",
      "approach": "[Recursive Approach] Compare left and right subtrees - O(n) time and O(h) space. Check if left subtree is mirror of right subtree. Compare left.left with right.right and left.right with right.left."
    }
  },
  {
    "id": 11,
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "Easy",
    "type": "Binary Tree / Stack",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    "examples": [
      { "input": "root=[1,null,2,3]", "output": "[1,3,2]" }
    ],
    "constraints": [
      "The number of nodes is in the range [0, 100]",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      { "input": "root=[1,null,2,3]", "output": "[1,3,2]" },
      { "input": "root=[]", "output": "[1,3,2]" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/lxTGsVXjwvM",
      "approach": "[Recursive Approach] Left-Root-Right traversal - O(n) time and O(h) space. Visit left subtree, process root, visit right subtree. [Iterative Approach] Use stack to simulate recursion - O(n) time and O(h) space."
    }
  },
  {
    "id": 12,
    "title": "Best Time to Buy and Sell Stock",
    "difficulty": "Easy",
    "type": "Array / Dynamic Programming",
    "description": "Given an array prices where prices[i] is the price of a stock on day i, return the maximum profit.",
    "examples": [
      { "input": "prices = [7,1,5,3,6,4]", "output": "5" }
    ],
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "testCases": [
      { "input": "prices=[7,1,5,3,6,4]", "output": "5" },
      { "input": "prices=[7,6,4,3,1]", "output": "5" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/1pkOgXD63yU",
      "approach": "[One Pass Approach] Track minimum price and maximum profit - O(n) time and O(1) space. Keep track of minimum price seen so far and calculate profit at each step. Update maximum profit if current profit is higher."
    }
  },
  {
    "id": 13,
    "title": "Maximum Depth of Binary Tree",
    "difficulty": "Medium",
    "type": "Binary Tree",
    "description": "Given the root of a binary tree, return its maximum depth.",
    "examples": [
      { "input": "root=[3,9,20,null,null,15,7]", "output": "3" }
    ],
    "constraints": [
      "The number of nodes is in the range [0, 10^4]",
      "-100 <= Node.val <= 100"
    ],
    "testCases": [
      { "input": "root=[3,9,20,null,null,15,7]", "output": "3" },
      { "input": "root=[]", "output": "3" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/hTM3phVI6YQ",
      "approach": "[Recursive Approach] DFS traversal - O(n) time and O(h) space. Maximum depth = 1 + max(depth of left subtree, depth of right subtree). Base case: null node has depth 0."
    }
  },
  {
    "id": 14,
    "title": "Valid Palindrome",
    "difficulty": "Hard",
    "type": "String / Two Pointers",
    "description": "Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.",
    "examples": [
      { "input": "s='A man, a plan, a canal: Panama'", "output": "true" }
    ],
    "constraints": [
      "1 <= s.length <= 2 * 10^5",
      "s consists only of printable ASCII characters."
    ],
    "testCases": [
      { "input": "s='A man, a plan, a canal: Panama'", "output": "true" },
      { "input": "s='race a car'", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/jJXJ16kPFWg",
      "approach": "[Two Pointer Approach] Compare characters from both ends - O(n) time and O(1) space. Use two pointers from start and end, skip non-alphanumeric characters, compare characters in lowercase."
    }
  },
  {
    "id": 15,
    "title": "Single Number",
    "difficulty": "Hard",
    "type": "Bit Manipulation / Hash Table",
    "description": "Given a non-empty array of integers, every element appears twice except for one. Find that single one.",
    "examples": [
      { "input": "nums=[2,2,1]", "output": "1" }
    ],
    "constraints": [
      "1 <= nums.length <= 3 * 10^4",
      "-3 * 10^4 <= nums[i] <= 3 * 10^4"
    ],
    "testCases": [
      { "input": "nums=[2,2,1]", "output": "1" },
      { "input": "nums=[4,1,2,1,2]", "output": "1" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/qMPX1AOa83k",
      "approach": "[XOR Approach] Use XOR properties - O(n) time and O(1) space. XOR all numbers together. Since a XOR a = 0 and a XOR 0 = a, all duplicate numbers cancel out, leaving only the single number."
    }
  },
  {
    "id": 16,
    "title": "Intersection of Two Arrays II",
    "difficulty": "Easy",
    "type": "Hash Table / Sorting",
    "description": "Given two integer arrays nums1 and nums2, return their intersection.",
    "examples": [
      { "input": "nums1=[1,2,2,1], nums2=[2,2]", "output": "[2,2]" }
    ],
    "constraints": [
      "1 <= nums1.length, nums2.length <= 1000",
      "0 <= nums1[i], nums2[i] <= 1000"
    ],
    "testCases": [
      { "input": "nums1=[1,2,2,1], nums2=[2,2]", "output": "[2,2]" },
      { "input": "nums1=[4,9,5], nums2=[9,4,9,8,4]", "output": "[2,2]" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/lKuK69-hMcc",
      "approach": "[Hash Map Approach] Count frequencies - O(m+n) time and O(min(m,n)) space. Count frequency of elements in smaller array, iterate through larger array and add common elements to result."
    }
  },
  {
    "id": 17,
    "title": "Plus One",
    "difficulty": "Easy",
    "type": "Array / Math",
    "description": "Given a non-empty array of digits representing a non-negative integer, increment one to the integer.",
    "examples": [
      { "input": "digits=[1,2,3]", "output": "[1,2,4]" }
    ],
    "constraints": [
      "1 <= digits.length <= 100",
      "0 <= digits[i] <= 9",
      "digits does not contain leading 0."
    ],
    "testCases": [
      { "input": "digits=[1,2,3]", "output": "[1,2,4]" },
      { "input": "digits=[9]", "output": "[1,2,4]" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/jIaA8boiG1s",
      "approach": "[Reverse Iteration] Handle carry propagation - O(n) time and O(1) space. Start from last digit, add 1, handle carry. If all digits become 0 (like 999+1), create new array with 1 followed by zeros."
    }
  },
  {
    "id": 18,
    "title": "Linked List Cycle",
    "difficulty": "Easy",
    "type": "Linked List / Hash Table / Two Pointers",
    "description": "Given head, the head of a linked list, determine if the linked list has a cycle.",
    "examples": [
      { "input": "head=[3,2,0,-4], pos=1", "output": "true" }
    ],
    "constraints": [
      "The number of nodes in the list is in the range [0, 10^4]",
      "-10^5 <= Node.val <= 10^5",
      "pos is -1 or a valid index in the linked list."
    ],
    "testCases": [
      { "input": "head=[3,2,0,-4], pos=1", "output": "true" },
      { "input": "head=[1,2], pos=0", "output": "true" },
      { "input": "head=[1], pos=-1", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/gBTe7lFR3vc",
      "approach": "[Floyd's Cycle Detection] Two pointer technique - O(n) time and O(1) space. Use slow and fast pointers. If there's a cycle, fast pointer will eventually meet slow pointer."
    }
  },
  {
    "id": 19,
    "title": "Min Stack",
    "difficulty": "Medium",
    "type": "Stack / Design",
    "description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    "examples": [
      { "input": "push(-2), push(0), push(-3), getMin()", "output": "-3" }
    ],
    "constraints": [
      "-2^31 <= val <= 2^31 - 1",
      "Methods pop, top, and getMin operations will always be called on non-empty stacks."
    ],
    "testCases": [
      { "input": "push(-2), push(0), push(-3), getMin()", "output": "-3" },
      { "input": "pop(), top()", "output": "-3" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/V09NfaGf2ao",
      "approach": "[Auxiliary Stack] Use two stacks - O(1) time for all operations and O(n) space. Main stack for elements, auxiliary stack to track minimum at each level. Push to aux stack only when new minimum is found."
    }
  },
  {
    "id": 20,
    "title": "Valid Anagram",
    "difficulty": "Easy",
    "type": "Hash Table / String / Sorting",
    "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    "examples": [
      { "input": "s='anagram', t='nagaram'", "output": "true" }
    ],
    "constraints": [
      "1 <= s.length, t.length <= 5 * 10^4",
      "s and t consist of lowercase English letters."
    ],
    "testCases": [
      { "input": "s='anagram', t='nagaram'", "output": "true" },
      { "input": "s='rat', t='car'", "output": "true" }
    ],
    "solutions": {
      "youtube": "https://youtu.be/9UtInBqnCgA",
      "approach": "[Frequency Count] Count character frequencies - O(n) time and O(1) space. Count frequency of each character in both strings. If frequencies match, strings are anagrams. [Sorting Approach] Sort both strings - O(n log n) time and O(1) space."
    }
  }
]
